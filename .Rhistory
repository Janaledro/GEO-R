###Script para alluviales
library(alluvial)
install.packages("alluvial")
install.packages("plyr")
install.packages("biobase")
install.packages("Biobase")
install.packages("GEOquery")
source("https://bioconductor.org/biocLite.R")
biocLite("GEOquery")
install.packages("XML")
install.packages("xml2")
install.packages("xml2")
install.packages("XML")
biocLite("GEOquery")
install.packages("RCurl")
install.packages("rCUR")
install.packages("curl")
install.packages("RCurl")
biocLite("GEOquery")
biocLite("GEOquery")
install.packages("ggplot2")
################################################################
#   Boxplot for selected GEO samples
library(Biobase)
library(GEOquery)
vignette(GEOquery)
vignette("GEOquery")
#A continuación se cargará la librería 'ggplot' para hacer gráficos
library("ggplot2")
library("ggplot2")
library("reshape2")
library("alluvial")
library("dplyr")
setwd("~/GEO-R/")
library("ggplot2")
library("reshape2")
library("alluvial")
library("dplyr")
#A continuación se leerán los datos. Se recuerda ubicar el espacio de trabajo
#con "setwd()"
GEO<-read.csv(file="data/GEO_tablet.tsv", header = T, sep = "\t",
na.strings = "", stringsAsFactors = T)
GEO.DF<-GEO[grepl(GEO$FECHA_DE_PUBLICACION, pattern = "Public_on_"),]
#EN ESTA LÍNEA SE GENERARÁ UN DATA FRAME CON LAS LÍNEAS FALTANTES
GEO_DESFASADO.DF<-GEO[grep(GEO$FECHA_DE_PUBLICACION, pattern = "Public_on_", invert = T),]
SPPs <- as.character(GEO.DF$ORGANISMO)
SPPstr<-unlist(strsplit(SPPs, split = ","))
ESPECIES<-grep("!Sample_", SPPstr, value = T, invert = T)
ESPECIES.DF<- data.frame(ESPECIES, stringsAsFactors = T)
ESPECIES.DF<-droplevels(ESPECIES.DF)
my.summary<-summary(ESPECIES.DF, maxsum = 7)
my.summary<-data.frame(ORGANISMO = c("Homo sapiens", "Mus musculus", "Arabidopsis thaliana",
"Drosophila melanogaster", "Rattus novergicus",
"Saccharomyces cerevisiae","Otros"),
NUMERO_DE_ENTRADAS_EN_LA_TABLA = c(21905, 14898, 1876, 1792,
1506,1289,12609),
stringsAsFactors = F)
#DESBLOQUEAR ESTE BLOQUE EN CASO DE TENER YA LA TABLA RESULTADO DEL LOOP. ESTO ES
#ÚTIL PARA EVITAR REPETIR EL LOOP CON LA TABLA ORIGINAL
#write.csv("GEO.DF", "data/GEO_DF.tsv")
read.csv("data/GEO_DF.tsv", header = T, sep = "\t", stringsAsFactors = T,
na.strings = "")
#DESBLOQUEAR ESTE BLOQUE EN CASO DE TENER YA LA TABLA RESULTADO DEL LOOP. ESTO ES
#ÚTIL PARA EVITAR REPETIR EL LOOP CON LA TABLA ORIGINAL
#write.csv("GEO.DF", "data/GEO_DF.tsv")
GEO.DF<-read.csv("data/GEO_DF.tsv", header = T, sep = "\t", stringsAsFactors = T,
na.strings = "")
GEO.DF$ANO <-as.factor(GEO.DF$ANO)
GEO.DF$MES <-as.factor(GEO.DF$MES)
GEO.DF$DIA <-as.factor(GEO.DF$DIA)
#DESBLOQUEAR ESTE BLOQUE EN CASO DE TENER YA LA TABLA RESULTADO DEL LOOP. ESTO ES
#ÚTIL PARA EVITAR REPETIR EL LOOP CON LA TABLA ORIGINAL
#write.csv("GEO.DF", "data/GEO_DF.tsv")
GEO.DF<-read.csv("data/GEO_DF.tsv", header = T, sep = "\t", stringsAsFactors = T,
na.strings = "")
View(ESPECIES.DF)
View(GEO.DF)
GEO.DF$ORGANISMO<-droplevels(GEO.DF$ORGANISMO)
my.summary <- summary(GEO$ORGANISMO, maxsum = 7)
NUMEROS_POR_ESPECIE.DF<-data.frame(ORGANISMO=names(my.summary), NUMERO_DE_ENTRADAS_EN_LA_TABLA=my.summary)
####
#A continuación se realizarán gráficos de comparación a lo largo del tiempo
GEO.DF$ANO <-0
GEO.DF$MES <-0
GEO.DF$DIA <-0
GEO.DF$FECHA_DE_PUBLICACION <- as.character(GEO.DF$FECHA_DE_PUBLICACION)
for(i in 1:nrow(GEO.DF)){
message(paste0("Operando sobre la línea ", i))
GEO.DF$ANO[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[5]
GEO.DF$MES[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[4]
GEO.DF$DIA[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[3]
}
GEO.DF<-GEO[grepl(GEO$FECHA_DE_PUBLICACION, pattern = "Public_on_"),]
for(i in 1:nrow(GEO.DF)){
message(paste0("Operando sobre la línea ", i))
GEO.DF$ANO[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[5]
GEO.DF$MES[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[4]
GEO.DF$DIA[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[3]
}
GEO.DF$FECHA_DE_PUBLICACION <- as.character(GEO.DF$FECHA_DE_PUBLICACION)
message(paste0("Operando sobre la línea ", i))
####
#A continuación se realizarán gráficos de comparación a lo largo del tiempo
GEO.DF$ANO <-0
GEO.DF$MES <-0
GEO.DF$DIA <-0
GEO.DF$FECHA_DE_PUBLICACION <- as.character(GEO.DF$FECHA_DE_PUBLICACION)
for(i in 1:nrow(GEO.DF)){
message(paste0("Operando sobre la línea ", i))
GEO.DF$ANO[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[5]
GEO.DF$MES[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[4]
GEO.DF$DIA[i] <- unlist(strsplit(GEO.DF$FECHA_DE_PUBLICACION[i], split = "_"))[3]
}
#DESBLOQUEAR ESTE BLOQUE EN CASO DE TENER YA LA TABLA RESULTADO DEL LOOP. ESTO ES
#ÚTIL PARA EVITAR REPETIR EL LOOP CON LA TABLA ORIGINAL
write.csv("GEO.DF", "data/GEO_DF.tsv")
#DESBLOQUEAR ESTE BLOQUE EN CASO DE TENER YA LA TABLA RESULTADO DEL LOOP. ESTO ES
#ÚTIL PARA EVITAR REPETIR EL LOOP CON LA TABLA ORIGINAL
write.table(x="GEO.DF", file = "data/GEO_DF.tsv", sep = "\t", na = "")
View(GEO.DF)
#DESBLOQUEAR ESTE BLOQUE EN CASO DE TENER YA LA TABLA RESULTADO DEL LOOP. ESTO ES
#ÚTIL PARA EVITAR REPETIR EL LOOP CON LA TABLA ORIGINAL
write.table(x=GEO.DF, file = "data/GEO_DF.tsv", sep = "\t", na = "")
GEO.DF$ANO <-as.factor(GEO.DF$ANO)
GEO.DF$MES <-as.factor(GEO.DF$MES)
GEO.DF$DIA <-as.factor(GEO.DF$DIA)
fechas<- summary(GEO.DF$ANO)
NUMEROS_POR_ANO <- data.frame(ANO=names(fechas), NUMERO_DE_ENTRADAS = fechas)
gp_numero_de_entradas<-ggplot(NUMEROS_POR_ANO, aes(x=ANO, y=NUMERO_DE_ENTRADAS)) +
geom_point()
####
#A CONTINUACIÓN GRAFICARMOS EL NÚMERO DE PROYECTOS CON DESCRIPCIÓN RESPECTO AL AÑO
#PRIMERO CREAREMOS UN VECTOR CON TODOS LOS AÑOS REGISTRADOS EN GEO
anos <- levels(GEO.DF$ANO)
DATOS_POR_ANO.DF <- data.frame(ANO=factor(anos),
CON_RESUMEN=integer(length(anos)),
SIN_RESUMEN=integer(length(anos)),
TOTAL_DE_CARACTERES=numeric(length(anos)),
ARRAY=integer(length(anos)),
SEQ=integer(length(anos)),
NUMERO_DE_ESTUDIOS_EN_HUMANO =integer(length(anos)),
NUMERO_DE_ESTUDIOS_EN_RATON=integer(length(anos)),
stringsAsFactors=FALSE)
GEO.DF$RESUMEN_DEL_PROYECTO<-as.character(GEO.DF$RESUMEN_DEL_PROYECTO)
for (i in 1:nrow(DATOS_POR_ANO.DF)){
message(paste0("Creando el data frame en la línea ", i))
DATOS_POR_ANO.DF$ANO[i] <- anos[i]
DATOS_POR_ANO.DF$CON_RESUMEN[i] <-sum(!is.na(GEO.DF[GEO.DF$ANO == anos[i],"RESUMEN_DEL_PROYECTO"]))
DATOS_POR_ANO.DF$SIN_RESUMEN[i]<-sum(is.na(GEO.DF[GEO.DF$ANO == anos[i],"RESUMEN_DEL_PROYECTO"]))
DATOS_POR_ANO.DF$TOTAL_DE_CARACTERES[i]<- nchar(paste(GEO.DF[GEO.DF$ANO == anos[i],"RESUMEN_DEL_PROYECTO"], collapse = "")) / DATOS_POR_ANO.DF$CON_RESUMEN[i]
DATOS_POR_ANO.DF$ARRAY[i]<-length(grep("array", GEO.DF[GEO.DF$ANO == anos[i], "SERIES_TYPE"]))
DATOS_POR_ANO.DF$SEQ[i]<-length(grep("seq", GEO.DF[GEO.DF$ANO == anos[i], "SERIES_TYPE"]))
DATOS_POR_ANO.DF$NUMERO_DE_ESTUDIOS_EN_HUMANO[i]<-length(grep("Homo_sapiens", GEO.DF[GEO.DF$ANO == anos[i], "ORGANISMO"]))
DATOS_POR_ANO.DF$NUMERO_DE_ESTUDIOS_EN_RATON[i]<-length(grep("Mus_musculus", GEO.DF[GEO.DF$ANO == anos[i], "ORGANISMO"]))
}
gp_tdc<-ggplot(DATOS_POR_ANO.DF, aes(x=ANO, y=TOTAL_DE_CARACTERES)) +
geom_point()
#GRÁFICA DE ESTUDIOS CON MICROARREGOS VS AÑOS
gp_microarreglos_vs_años<-ggplot(DATOS_POR_ANO.DF, aes(x=ANO, y=ARRAY)) +
geom_point()
#GRÁFICA DE ESTUDIOS CON SECUENCIACIÓN VS AÑOS
gp_seq_vs_anos<-ggplot(DATOS_POR_ANO.DF, aes(x=ANO, y=SEQ)) +
geom_point()
#GRÁFICA DE ESTUDIOS EN HUMANO VS AÑOS
gp_hs_vs_anos<-ggplot(DATOS_POR_ANO.DF, aes(x=ANO, y=NUMERO_DE_ESTUDIOS_EN_HUMANO)) +
geom_point()
#GRÁFICA DE ESTUDIOS EN RATÓN VS AÑOS
gp_mm_vs_anos<-ggplot(DATOS_POR_ANO.DF, aes(x=ANO, y=NUMERO_DE_ESTUDIOS_EN_RATON)) +
geom_point()
#GRÁFICA DE ESTUDIOS EN HUMANO VS RATÓN A TRAVÉS DEL TIEMPO. PRIMERO HAY QUE ORGANIZAR
#LOS DATOS PARA COMPARARLOS EN PARALELO
FRAME.DF<-data.frame(ANO=DATOS_POR_ANO.DF$ANO,
NUMERO_DE_ESTUDIOS_EN_HUMANO=DATOS_POR_ANO.DF$NUMERO_DE_ESTUDIOS_EN_HUMANO,
NUMERO_DE_ESTUDIOS_EN_RATON=DATOS_POR_ANO.DF$NUMERO_DE_ESTUDIOS_EN_RATON)
data.m<-melt(FRAME.DF, id.vars= "ANO")
#GRÁFICA QUE COMPARA ESTUDIOS REALIZADOS EN HUMANOS VS RATÓN CON BARRAS
bp_hs_vs_mm<-ggplot(data.m, aes(ANO, value))+
geom_bar(aes( fill= variable), position= "dodge", stat="identity") +
scale_fill_brewer(palette="Set1")
#GRÁFICA QUE COMPARA ESTUDIOS REALIZADOS EN HUMANOS VS RATÓN CON PUNTOS
gp_hs_vs_mm<-ggplot(data.m, aes(x=ANO, y=value)) +
geom_point(aes(fill=variable, color=variable)) +
scale_color_brewer(palette="Set1")
#REALIZACIÓN DE ALLUVIAL PLOT PARA SUMARIZAR LA INFORMACIÓN PREVIA
FRAME.DF<-data.frame(ANO=DATOS_POR_ANO.DF$ANO,
NUMERO_DE_ESTUDIOS_EN_HUMANO=DATOS_POR_ANO.DF$NUMERO_DE_ESTUDIOS_EN_HUMANO,
NUMERO_DE_ESTUDIOS_EN_RATON=DATOS_POR_ANO.DF$NUMERO_DE_ESTUDIOS_EN_RATON,
ARRAY=DATOS_POR_ANO.DF$ARRAY,
SEQ=DATOS_POR_ANO.DF$SEQ, stringsAsFactors = T)
palabras<-c("_addiction_", "_alcoholism_", "_OCD_", "_coccaine_",
"_drug_abuse_", "_alcohol_", "_reward_","_substance_related_disorders_",
"_dopamine_", "_reward_mechanisms_",
"_alcohol_dependence_", "_marijuana_")
####
#CREANDO UN VACTOR VACÍO DONDE SE CONCATENARÁN TODOS LOS VECTORES DE CADA PALABRA
VECTOR_FINAL_DE_GREPS<-NA
#A CONTINUACIÓN CREAMOS EL LOOP FOR PARA BUSCAR UN VECTOR DE MATCHES DE MANERA
#ITERATIVA
for(i in 1:length(palabras)){
message(paste0("Estoy buscando la palabra ", palabras[i]))
indices<-grep(pattern = palabras[i], GEO.DF$RESUMEN_DEL_PROYECTO,
ignore.case = T)
indices<-grep(pattern = "cancer", GEO.DF$RESUMEN_DEL_PROYECTO,
ignore.case = T, invert = T)
#aquí se tiene que concatenar el vector "indices" con el vector final de greps
VECTOR_FINAL_DE_GREPS<-as.vector(rbind(VECTOR_FINAL_DE_GREPS, indices))
#c( matrix(c(VECTOR_FINAL_DE_GREPS,indices), nrow=2, byrow=TRUE) )
}
#VAMOS A ELIMINAR LOS VALORES NA
VECTOR_FINAL_DE_GREPS <- VECTOR_FINAL_DE_GREPS[!is.na(VECTOR_FINAL_DE_GREPS)]
#Y AHORA VAMOS A ELIMINAR ELEMENTOS REPETIDOS
VECTOR_FINAL_DE_GREPS<-unique(VECTOR_FINAL_DE_GREPS)
#AHORA VAMOS A EXTRAER LAS FILAS QUE NOS INTERESAN
GEO_FILTRADO<-GEO.DF[VECTOR_FINAL_DE_GREPS,]
#AHORA VAMOS A EXTRAER LAS FILAS QUE NOS INTERESAN
GEO_FILTRADO<-GEO.DF[VECTOR_FINAL_DE_GREPS,]
GEO_FILTRADO<-PARA_PROBAR_GREPS.DF[VECTOR_FINAL_DE_GREPS,]
#A CONTINUACIÓN SE REMOVERÁN TODOS LOS DATOS RELACIONADOS CON CÁNCER
GEO_FILTRADO.DF<-GEO_FILTRADO[grep("_cancer_", GEO_FILTRADO$RESUMEN_DEL_PROYECTO),]
#A CONTINUACIÓN SE REMOVERÁN TODOS LOS DATOS RELACIONADOS CON CÁNCER
GEO_FILTRADO.DF<-GEO_FILTRADO[grep("_cancer_", GEO_FILTRADO$RESUMEN_DEL_PROYECTO,
invert = T),]
View(GEO_FILTRADO.DF)
